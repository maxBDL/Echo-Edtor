import {
  Fragment,
  computed,
  createBaseVNode,
  createElementBlock,
  defineComponent,
  getCurrentScope,
  isRef,
  onScopeDispose,
  openBlock,
  ref,
  shallowRef,
  unref,
  watch,
  watchEffect
} from "./chunk-SE5EWVSA.js";
import "./chunk-RSJERJUL.js";

// node_modules/vue-audio-visual/dist/vue-audio-visual.js
var Ke = Object.defineProperty;
var Ze = (n, e, t) => e in n ? Ke(n, e, { enumerable: true, configurable: true, writable: true, value: t }) : n[e] = t;
var l = (n, e, t) => (Ze(n, typeof e != "symbol" ? e + "" : e, t), t);
var Le;
var Ce = typeof window < "u";
var rt = (n) => typeof n == "string";
var it = () => {
};
Ce && ((Le = window == null ? void 0 : window.navigator) == null ? void 0 : Le.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
function m(n) {
  return typeof n == "function" ? n() : unref(n);
}
function Be(n, e = false, t = "Timeout") {
  return new Promise((r, i) => {
    setTimeout(e ? () => i(t) : r, n);
  });
}
function at(n) {
  return n;
}
function ot(n, ...e) {
  return e.some((t) => t in n);
}
function de() {
  const n = [], e = (i) => {
    const a = n.indexOf(i);
    a !== -1 && n.splice(a, 1);
  };
  return {
    on: (i) => (n.push(i), {
      off: () => e(i)
    }),
    off: e,
    trigger: (i) => {
      n.forEach((a) => a(i));
    }
  };
}
function Se(n) {
  return getCurrentScope() ? (onScopeDispose(n), true) : false;
}
function fe(n) {
  return typeof n == "function" ? computed(n) : ref(n);
}
function ye(n, e = false) {
  function t(s, { flush: h = "sync", deep: g = false, timeout: p, throwOnTimeout: N } = {}) {
    let P = null;
    const q = [new Promise((M) => {
      P = watch(n, (z) => {
        s(z) !== e && (P == null || P(), M(z));
      }, {
        flush: h,
        deep: g,
        immediate: true
      });
    })];
    return p != null && q.push(Be(p, N).then(() => m(n)).finally(() => P == null ? void 0 : P())), Promise.race(q);
  }
  function r(s, h) {
    if (!isRef(s))
      return t((z) => z === s, h);
    const { flush: g = "sync", deep: p = false, timeout: N, throwOnTimeout: P } = h != null ? h : {};
    let H = null;
    const M = [new Promise((z) => {
      H = watch([n, s], ([A, $]) => {
        e !== (A === $) && (H == null || H(), z(A));
      }, {
        flush: g,
        deep: p,
        immediate: true
      });
    })];
    return N != null && M.push(Be(N, P).then(() => m(n)).finally(() => (H == null || H(), m(n)))), Promise.race(M);
  }
  function i(s) {
    return t((h) => Boolean(h), s);
  }
  function a(s) {
    return r(null, s);
  }
  function o(s) {
    return r(void 0, s);
  }
  function d(s) {
    return t(Number.isNaN, s);
  }
  function c(s, h) {
    return t((g) => {
      const p = Array.from(g);
      return p.includes(s) || p.includes(m(s));
    }, h);
  }
  function u(s) {
    return f(1, s);
  }
  function f(s = 1, h) {
    let g = -1;
    return t(() => (g += 1, g >= s), h);
  }
  return Array.isArray(m(n)) ? {
    toMatch: t,
    toContains: c,
    changed: u,
    changedTimes: f,
    get not() {
      return ye(n, !e);
    }
  } : {
    toMatch: t,
    toBe: r,
    toBeTruthy: i,
    toBeNull: a,
    toBeNaN: d,
    toBeUndefined: o,
    changed: u,
    changedTimes: f,
    get not() {
      return ye(n, !e);
    }
  };
}
function lt(n) {
  return ye(n);
}
function ct(n, e, t = {}) {
  const {
    immediate: r = true
  } = t, i = ref(false);
  let a = null;
  function o() {
    a && (clearTimeout(a), a = null);
  }
  function d() {
    i.value = false, o();
  }
  function c(...u) {
    o(), i.value = true, a = setTimeout(() => {
      i.value = false, a = null, n(...u);
    }, m(e));
  }
  return r && (i.value = true, Ce && c()), Se(d), {
    isPending: i,
    start: c,
    stop: d
  };
}
function st(n) {
  var e;
  const t = m(n);
  return (e = t == null ? void 0 : t.$el) != null ? e : t;
}
var We = Ce ? window : void 0;
function x(...n) {
  let e, t, r, i;
  if (rt(n[0]) || Array.isArray(n[0]) ? ([t, r, i] = n, e = We) : [e, t, r, i] = n, !e)
    return it;
  Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]);
  const a = [], o = () => {
    a.forEach((f) => f()), a.length = 0;
  }, d = (f, s, h) => (f.addEventListener(s, h, i), () => f.removeEventListener(s, h, i)), c = watch(() => st(e), (f) => {
    o(), f && a.push(...t.flatMap((s) => r.map((h) => d(f, s, h))));
  }, { immediate: true, flush: "post" }), u = () => {
    c(), o();
  };
  return Se(u), u;
}
var me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
var ve = "__vueuse_ssr_handlers__";
me[ve] = me[ve] || {};
me[ve];
function Fe(n, e = {}) {
  const {
    immediate: t = true,
    window: r = We
  } = e, i = ref(false);
  let a = null;
  function o() {
    !i.value || !r || (n(), a = r.requestAnimationFrame(o));
  }
  function d() {
    !i.value && r && (i.value = true, o());
  }
  function c() {
    i.value = false, a != null && r && (r.cancelAnimationFrame(a), a = null);
  }
  return t && d(), Se(c), {
    isActive: i,
    pause: c,
    resume: d
  };
}
var ut = Object.defineProperty;
var dt = Object.defineProperties;
var ft = Object.getOwnPropertyDescriptors;
var Oe = Object.getOwnPropertySymbols;
var ht = Object.prototype.hasOwnProperty;
var yt = Object.prototype.propertyIsEnumerable;
var Ne = (n, e, t) => e in n ? ut(n, e, { enumerable: true, configurable: true, writable: true, value: t }) : n[e] = t;
var v = (n, e) => {
  for (var t in e || (e = {}))
    ht.call(e, t) && Ne(n, t, e[t]);
  if (Oe)
    for (var t of Oe(e))
      yt.call(e, t) && Ne(n, t, e[t]);
  return n;
};
var E = (n, e) => dt(n, ft(e));
var mt = {
  json: "application/json",
  text: "text/plain",
  formData: "multipart/form-data"
};
function ae(n) {
  return ot(n, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch");
}
function vt(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function Q(n) {
  return typeof Headers < "u" && n instanceof Headers ? Object.fromEntries([...n.entries()]) : n;
}
function G(n, ...e) {
  return n === "overwrite" ? async (t) => {
    const r = e[e.length - 1];
    return r !== void 0 && await r(t), t;
  } : async (t) => (await e.reduce((r, i) => r.then(async () => {
    i && (t = v(v({}, t), await i(t)));
  }), Promise.resolve()), t);
}
function pt(n = {}) {
  const e = n.combination || "chain", t = n.options || {}, r = n.fetchOptions || {};
  function i(a, ...o) {
    const d = computed(() => {
      const f = m(n.baseUrl), s = m(a);
      return f && !vt(s) ? bt(f, s) : s;
    });
    let c = t, u = r;
    return o.length > 0 && (ae(o[0]) ? c = E(v(v({}, c), o[0]), {
      beforeFetch: G(e, t.beforeFetch, o[0].beforeFetch),
      afterFetch: G(e, t.afterFetch, o[0].afterFetch),
      onFetchError: G(e, t.onFetchError, o[0].onFetchError)
    }) : u = E(v(v({}, u), o[0]), {
      headers: v(v({}, Q(u.headers) || {}), Q(o[0].headers) || {})
    })), o.length > 1 && ae(o[1]) && (c = E(v(v({}, c), o[1]), {
      beforeFetch: G(e, t.beforeFetch, o[1].beforeFetch),
      afterFetch: G(e, t.afterFetch, o[1].afterFetch),
      onFetchError: G(e, t.onFetchError, o[1].onFetchError)
    })), gt(d, u, c);
  }
  return i;
}
function gt(n, ...e) {
  var t;
  const r = typeof AbortController == "function";
  let i = {}, a = { immediate: true, refetch: false, timeout: 0 };
  const o = {
    method: "GET",
    type: "text",
    payload: void 0
  };
  e.length > 0 && (ae(e[0]) ? a = v(v({}, a), e[0]) : i = e[0]), e.length > 1 && ae(e[1]) && (a = v(v({}, a), e[1]));
  const {
    fetch: d = (t = We) == null ? void 0 : t.fetch,
    initialData: c,
    timeout: u
  } = a, f = de(), s = de(), h = de(), g = ref(false), p = ref(false), N = ref(false), P = ref(null), H = shallowRef(null), q = shallowRef(null), M = shallowRef(c), z = computed(() => r && p.value);
  let A, $;
  const Te = () => {
    r && A && A.abort();
  }, ce = (w) => {
    p.value = w, g.value = !w;
  };
  u && ($ = ct(Te, u, { immediate: false }));
  const ee = async (w = false) => {
    var k;
    ce(true), q.value = null, P.value = null, N.value = false, A = void 0, r && (A = new AbortController(), A.signal.onabort = () => N.value = true, i = E(v({}, i), {
      signal: A.signal
    }));
    const T = {
      method: o.method,
      headers: {}
    };
    if (o.payload) {
      const ne = Q(T.headers);
      o.payloadType && (ne["Content-Type"] = (k = mt[o.payloadType]) != null ? k : o.payloadType);
      const re = m(o.payload);
      T.body = o.payloadType === "json" ? JSON.stringify(re) : re;
    }
    let U = false;
    const L = { url: m(n), options: v(v({}, T), i), cancel: () => {
      U = true;
    } };
    if (a.beforeFetch && Object.assign(L, await a.beforeFetch(L)), U || !d)
      return ce(false), Promise.resolve(null);
    let B = null;
    return $ && $.start(), new Promise((ne, re) => {
      var ke;
      d(L.url, E(v(v({}, T), L.options), {
        headers: v(v({}, Q(T.headers)), Q((ke = L.options) == null ? void 0 : ke.headers))
      })).then(async (_) => {
        if (H.value = _, P.value = _.status, B = await _[o.type](), a.afterFetch && P.value >= 200 && P.value < 300 && ({ data: B } = await a.afterFetch({ data: B, response: _ })), M.value = B, !_.ok)
          throw new Error(_.statusText);
        return f.trigger(_), ne(_);
      }).catch(async (_) => {
        let Ae = _.message || _.name;
        return a.onFetchError && ({ data: B, error: Ae } = await a.onFetchError({ data: B, error: _, response: H.value })), M.value = B, q.value = Ae, s.trigger(_), w ? re(_) : ne(null);
      }).finally(() => {
        ce(false), $ && $.stop(), h.trigger(null);
      });
    });
  }, He = fe(a.refetch);
  watch([
    He,
    fe(n)
  ], ([w]) => w && ee(), { deep: true });
  const te = {
    isFinished: g,
    statusCode: P,
    response: H,
    error: q,
    data: M,
    isFetching: p,
    canAbort: z,
    aborted: N,
    abort: Te,
    execute: ee,
    onFetchResponse: f.on,
    onFetchError: s.on,
    onFetchFinally: h.on,
    get: I("GET"),
    put: I("PUT"),
    post: I("POST"),
    delete: I("DELETE"),
    patch: I("PATCH"),
    head: I("HEAD"),
    options: I("OPTIONS"),
    json: R("json"),
    text: R("text"),
    blob: R("blob"),
    arrayBuffer: R("arrayBuffer"),
    formData: R("formData")
  };
  function I(w) {
    return (k, T) => {
      if (!p.value) {
        o.method = w, o.payload = k, o.payloadType = T, isRef(o.payload) && watch([
          He,
          fe(o.payload)
        ], ([L]) => L && ee(), { deep: true });
        const U = m(o.payload);
        return !T && U && Object.getPrototypeOf(U) === Object.prototype && (o.payloadType = "json"), E(v({}, te), {
          then(L, B) {
            return se().then(L, B);
          }
        });
      }
    };
  }
  function se() {
    return new Promise((w, k) => {
      lt(g).toBe(true).then(() => w(te)).catch((T) => k(T));
    });
  }
  function R(w) {
    return () => {
      if (!p.value)
        return o.type = w, E(v({}, te), {
          then(k, T) {
            return se().then(k, T);
          }
        });
    };
  }
  return a.immediate && setTimeout(ee, 0), E(v({}, te), {
    then(w, k) {
      return se().then(w, k);
    }
  });
}
function bt(n, e) {
  return !n.endsWith("/") && !e.startsWith("/") ? `${n}/${e}` : `${n}${e}`;
}
var Me;
(function(n) {
  n.UP = "UP", n.RIGHT = "RIGHT", n.DOWN = "DOWN", n.LEFT = "LEFT", n.NONE = "NONE";
})(Me || (Me = {}));
var Ct = Object.defineProperty;
var ze = Object.getOwnPropertySymbols;
var St = Object.prototype.hasOwnProperty;
var Wt = Object.prototype.propertyIsEnumerable;
var Ee = (n, e, t) => e in n ? Ct(n, e, { enumerable: true, configurable: true, writable: true, value: t }) : n[e] = t;
var Ft = (n, e) => {
  for (var t in e || (e = {}))
    St.call(e, t) && Ee(n, t, e[t]);
  if (ze)
    for (var t of ze(e))
      Wt.call(e, t) && Ee(n, t, e[t]);
  return n;
};
var wt = {
  easeInSine: [0.12, 0, 0.39, 0],
  easeOutSine: [0.61, 1, 0.88, 1],
  easeInOutSine: [0.37, 0, 0.63, 1],
  easeInQuad: [0.11, 0, 0.5, 0],
  easeOutQuad: [0.5, 1, 0.89, 1],
  easeInOutQuad: [0.45, 0, 0.55, 1],
  easeInCubic: [0.32, 0, 0.67, 0],
  easeOutCubic: [0.33, 1, 0.68, 1],
  easeInOutCubic: [0.65, 0, 0.35, 1],
  easeInQuart: [0.5, 0, 0.75, 0],
  easeOutQuart: [0.25, 1, 0.5, 1],
  easeInOutQuart: [0.76, 0, 0.24, 1],
  easeInQuint: [0.64, 0, 0.78, 0],
  easeOutQuint: [0.22, 1, 0.36, 1],
  easeInOutQuint: [0.83, 0, 0.17, 1],
  easeInExpo: [0.7, 0, 0.84, 0],
  easeOutExpo: [0.16, 1, 0.3, 1],
  easeInOutExpo: [0.87, 0, 0.13, 1],
  easeInCirc: [0.55, 0, 1, 0.45],
  easeOutCirc: [0, 0.55, 0.45, 1],
  easeInOutCirc: [0.85, 0, 0.15, 1],
  easeInBack: [0.36, 0, 0.66, -0.56],
  easeOutBack: [0.34, 1.56, 0.64, 1],
  easeInOutBack: [0.68, -0.6, 0.32, 1.6]
};
Ft({
  linear: at
}, wt);
var O = (n) => n === void 0;
function y(n, e) {
  const t = m(n);
  return O(t) ? e : Number(t);
}
function j(n, e) {
  const t = m(n);
  return Array.isArray(t) ? t : t ? String(t) : e;
}
function b(n, e) {
  const t = m(n);
  return O(t) ? e : String(t);
}
function W(n, e) {
  const t = m(n);
  return O(t) ? e : Boolean(t);
}
var le = {
  src: {
    type: String,
    default: null
  },
  audioControls: {
    type: Boolean,
    default: true
  },
  corsAnonym: {
    type: Boolean,
    default: false
  },
  canvWidth: {
    type: Number,
    default: 300
  },
  canvHeight: {
    type: Number,
    default: 80
  },
  canvFillColor: {
    type: [String, Array],
    default: ""
  },
  placeholder: {
    type: Boolean,
    default: true
  }
};
var _t = {
  barWidth: {
    type: Number,
    default: 5
  },
  barSpace: {
    type: Number,
    default: 1
  },
  barColor: {
    type: [String, Array],
    default: "#0A0AFF"
  },
  capsHeight: {
    type: Number,
    default: 0
  },
  capsDropSpeed: {
    type: Number,
    default: 0.9
  },
  capsColor: {
    type: String,
    default: "#A0A0FF"
  },
  brickHeight: {
    type: Number,
    default: 0
  },
  brickSpace: {
    type: Number,
    default: 1
  },
  symmetric: {
    type: Boolean,
    default: false
  },
  fftSize: {
    type: Number,
    default: 1024
  }
};
var F = { ...le, ..._t };
function Pt() {
  return F;
}
var je = class {
  constructor(e) {
    l(this, "barColor");
    l(this, "barSpace");
    l(this, "barWidth");
    l(this, "brickHeight");
    l(this, "brickSpace");
    l(this, "canvFillColor");
    l(this, "canvHeight");
    l(this, "canvWidth");
    l(this, "capsColor");
    l(this, "capsDropSpeed");
    l(this, "capsHeight");
    l(this, "fftSize");
    l(this, "frqBits");
    l(this, "placeholder");
    l(this, "symmetric");
    this.barColor = j(e.barColor, F.barColor.default), this.barSpace = y(e.barSpace, F.barSpace.default), this.brickHeight = y(e.brickHeight, F.brickHeight.default), this.brickSpace = y(e.brickSpace, F.brickSpace.default), this.canvFillColor = j(e.canvFillColor, F.canvFillColor.default), this.canvHeight = y(e.canvHeight, F.canvHeight.default), this.canvWidth = y(e.canvWidth, F.canvWidth.default), this.capsColor = b(e.capsColor, F.capsColor.default), this.capsDropSpeed = y(e.capsDropSpeed, F.capsDropSpeed.default), this.capsHeight = y(e.capsHeight, F.capsHeight.default), this.fftSize = y(e.fftSize, F.fftSize.default), this.frqBits = this.fftSize >> 1, this.placeholder = W(e.placeholder, F.placeholder.default), this.symmetric = W(e.symmetric, F.symmetric.default);
    const t = y(e.barWidth, F.barWidth.default);
    this.barWidth = t > this.canvWidth ? this.canvWidth : t;
  }
  alignSym(e) {
    return this.symmetric ? (this.canvHeight - e) / 2 : 0;
  }
};
var Tt = {
  lineWidth: {
    type: Number,
    default: 2
  },
  lineColor: {
    type: [String, Array],
    default: "#9F9"
  },
  fftSize: {
    type: Number,
    default: 128
  }
};
var Ge = { ...le, ...Tt };
function Ht() {
  return Ge;
}
var De = class {
  constructor(e) {
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "lineWidth");
    l(this, "lineColor");
    l(this, "fftSize");
    l(this, "placeholder");
    const t = Ge;
    this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvFillColor = j(e.canvFillColor, t.canvFillColor.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.lineColor = j(e.lineColor, t.lineColor.default), this.fftSize = y(e.fftSize, t.fftSize.default), this.placeholder = W(e.placeholder, t.placeholder.default);
  }
};
var kt = {
  fftSize: {
    type: Number,
    default: 1024
  },
  canvWidth: {
    type: Number,
    default: 100
  },
  canvHeight: {
    type: Number,
    default: 100
  },
  radius: {
    type: Number,
    default: 0
  },
  lineWidth: {
    type: Number,
    default: 1
  },
  lineSpace: {
    type: Number,
    default: 1
  },
  outlineColor: {
    type: String,
    default: "#0000FF"
  },
  outlineWidth: {
    type: Number,
    default: 0.3
  },
  barWidth: {
    type: Number,
    default: 1
  },
  barLength: {
    type: Number,
    default: 0
  },
  barColor: {
    type: [String, Array],
    default: ["#FFFFFF", "#0000FF"]
  },
  progress: {
    type: Boolean,
    default: true
  },
  progressWidth: {
    type: Number,
    default: 1
  },
  progressColor: {
    type: String,
    default: "#0000FF"
  },
  progressClockwise: {
    type: Boolean,
    default: true
  },
  outlineMeterSpace: {
    type: Number,
    default: 3
  },
  playtime: {
    type: Boolean,
    default: false
  },
  playtimeFont: {
    type: String,
    default: "14px Monaco"
  },
  playtimeColor: {
    type: String,
    default: "#00f"
  },
  rotateGraph: {
    type: Boolean,
    default: false
  },
  rotateSpeed: {
    type: Number,
    default: 1e-3
  }
};
var Ve = { ...le, ...kt };
function At() {
  return Ve;
}
var ie = 1.5;
var qe = class {
  constructor(e) {
    l(this, "barColor");
    l(this, "barLength");
    l(this, "barWidth");
    l(this, "canvFillColor");
    l(this, "canvHeight");
    l(this, "canvWidth");
    l(this, "fftSize");
    l(this, "lineSpace");
    l(this, "lineWidth");
    l(this, "outlineColor");
    l(this, "outlineMeterSpace");
    l(this, "outlineWidth");
    l(this, "placeholder");
    l(this, "playtime");
    l(this, "playtimeColor");
    l(this, "playtimeFont");
    l(this, "progress");
    l(this, "progressClockwise");
    l(this, "progressColor");
    l(this, "progressWidth");
    l(this, "radius");
    l(this, "rotateGraph");
    l(this, "rotateSpeed");
    const t = Ve;
    this.barColor = j(e.barColor, t.barColor.default), this.barLength = y(e.barLength, t.barLength.default), this.barWidth = y(e.barWidth, t.barWidth.default), this.canvFillColor = j(e.canvFillColor, t.canvFillColor.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.fftSize = y(e.fftSize, t.fftSize.default), this.lineSpace = y(e.lineSpace, t.lineSpace.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.outlineColor = b(e.outlineColor, t.outlineColor.default), this.outlineMeterSpace = y(e.outlineMeterSpace, t.outlineMeterSpace.default), this.outlineWidth = y(e.outlineWidth, t.outlineWidth.default), this.lineWidth = y(e.lineWidth, t.lineWidth.default), this.placeholder = W(e.placeholder, t.placeholder.default), this.playtime = W(e.playtime, t.playtime.default), this.playtimeColor = b(e.playtimeColor, t.playtimeColor.default), this.playtimeFont = b(e.playtimeFont, t.playtimeFont.default), this.progress = W(e.progress, t.progress.default), this.progressClockwise = W(e.progressClockwise, t.progressClockwise.default), this.progressColor = b(e.progressColor, t.progressColor.default), this.progressWidth = y(e.progressWidth, t.progressWidth.default), this.radius = y(e.radius, t.radius.default), this.rotateGraph = W(e.rotateGraph, t.rotateGraph.default), this.rotateSpeed = y(e.rotateSpeed, t.rotateSpeed.default);
  }
  get cx() {
    return this.canvWidth / 2;
  }
  get cy() {
    return this.canvHeight / 2;
  }
  get r() {
    return this.radius > 0 ? this.radius : Math.round(this.canvWidth / 2 * 0.7);
  }
  get arcStep() {
    return Math.ceil(this.lineWidth + this.lineSpace);
  }
  get barLen() {
    return this.barLength > 0 ? this.barLength : this.canvWidth / 2 - this.r;
  }
  get angle() {
    const e = () => ie === 3.5 ? 1.5 : ie + this.rotateSpeed;
    return ie = this.rotateGraph ? e() : 1.5, Math.PI * ie;
  }
};
var Lt = {
  canvWidth: {
    type: Number,
    default: 500
  },
  canvHeight: {
    type: Number,
    default: 80
  },
  playedLineWidth: {
    type: Number,
    default: 0.5
  },
  playedLineColor: {
    type: String,
    default: "navy"
  },
  noplayedLineWidth: {
    type: Number,
    default: 0.5
  },
  noplayedLineColor: {
    type: String,
    default: "lime"
  },
  playtime: {
    type: Boolean,
    default: true
  },
  playtimeWithMs: {
    type: Boolean,
    default: true
  },
  playtimeFontSize: {
    type: Number,
    default: 12
  },
  playtimeFontFamily: {
    type: String,
    default: "monospace"
  },
  playtimeFontColor: {
    type: String,
    default: "grey"
  },
  playtimeTextBottom: {
    type: Boolean,
    default: false
  },
  playtimeSlider: {
    type: Boolean,
    default: true
  },
  playtimeSliderColor: {
    type: String,
    default: "red"
  },
  playtimeSliderWidth: {
    type: Number,
    default: 1
  },
  playtimeClickable: {
    type: Boolean,
    default: true
  },
  requester: {
    type: Function,
    default: fetch
  }
};
var Re = { ...le, ...Lt };
function Bt() {
  return Re;
}
var Ot = class {
  constructor(e) {
    l(this, "src");
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "currentTime");
    l(this, "duration");
    l(this, "playedLineWidth");
    l(this, "playedLineColor");
    l(this, "noplayedLineWidth");
    l(this, "noplayedLineColor");
    l(this, "playtime");
    l(this, "playtimeWithMs");
    l(this, "playtimeFontSize");
    l(this, "playtimeFontFamily");
    l(this, "playtimeFontColor");
    l(this, "playtimeTextBottom");
    l(this, "playtimeSlider");
    l(this, "playtimeSliderColor");
    l(this, "playtimeSliderWidth");
    l(this, "playtimeClickable");
    const t = Re;
    this.canvWidth = y(e.canvWidth, t.canvWidth.default), this.canvHeight = y(e.canvHeight, t.canvHeight.default), this.canvFillColor = j(e.canvFillColor, t.canvFillColor.default), this.playedLineWidth = y(e.playedLineWidth, t.playedLineWidth.default), this.playedLineColor = b(e.playedLineColor, t.playedLineColor.default), this.noplayedLineWidth = y(e.noplayedLineWidth, t.noplayedLineWidth.default), this.noplayedLineColor = b(e.noplayedLineColor, t.noplayedLineColor.default), this.playtime = W(e.playtime, t.playtime.default), this.playtimeWithMs = W(e.playtimeWithMs, t.playtimeWithMs.default), this.playtimeFontSize = y(e.playtimeFontSize, t.playtimeFontSize.default), this.playtimeFontFamily = b(e.playtimeFontFamily, t.playtimeFontFamily.default), this.playtimeFontColor = b(e.playtimeFontColor, t.playtimeFontColor.default), this.playtimeTextBottom = W(e.playtimeTextBottom, t.playtimeTextBottom.default), this.playtimeSlider = W(e.playtimeSlider, t.playtimeSlider.default), this.playtimeSliderColor = b(e.playtimeSliderColor, t.playtimeSliderColor.default), this.playtimeSliderWidth = y(e.playtimeSliderWidth, t.playtimeSliderWidth.default), this.playtimeClickable = W(e.playtimeClickable, t.playtimeClickable.default), this.src = O(e.src) ? null : String(e.src), this.currentTime = 0, this.duration = 0;
  }
  get playX() {
    return this.duration ? ~~(this.currentTime / this.duration * this.canvWidth) : 0;
  }
  get timePlayed() {
    const e = [
      this.currentTime / 3600,
      this.currentTime / 60 % 60,
      this.currentTime % 60
    ].map((r) => String(~~r).padStart(2, "0")).join(":");
    if (!this.playtimeWithMs)
      return e;
    const t = ~~(this.currentTime % 1 * 1e3);
    return [e, String(t).padStart(3, "0")].join(".");
  }
};
var Nt = {
  media: {
    type: Object,
    required: false,
    default: null
  },
  canvWidth: {
    type: Number,
    default: 0
  },
  canvClass: {
    type: String,
    default: ""
  },
  canvHeight: {
    type: Number,
    default: 0
  },
  canvFillColor: {
    type: String,
    default: ""
  },
  circleGradient: {
    type: Array,
    default: [[0, "palegreen"], [0.3, "lime"], [0.7, "limegreen"], [1, "green"]]
  },
  fftSize: {
    type: Number
  },
  type: {
    type: String,
    default: "wform"
  },
  frequLnum: {
    type: Number,
    default: 60
  },
  frequLineCap: {
    type: Boolean,
    default: false
  },
  frequDirection: {
    type: String,
    default: "lr"
  },
  lineColor: {
    type: String,
    default: "lime"
  },
  lineWidth: {
    type: Number
  },
  radius: {
    type: Number,
    default: 4
  },
  connectDestination: {
    type: Boolean,
    default: false
  },
  vbarBgColor: {
    type: String,
    default: "#e1e1e1"
  },
  vbarCaps: {
    type: Boolean,
    default: true
  },
  vbarSpace: {
    type: Number,
    default: 1
  },
  vbarWidth: {
    type: Number,
    default: 4
  },
  vbarFillColor: {
    type: String,
    default: "lime"
  },
  vbarRightColor: {
    type: String,
    default: "#c0c0c0"
  }
};
var Ue = { ...Nt };
function Mt() {
  return Ue;
}
var he = class {
  constructor(e) {
    l(this, "canvWidth");
    l(this, "canvHeight");
    l(this, "canvFillColor");
    l(this, "canvClass");
    l(this, "circleGradient");
    l(this, "fftSize");
    l(this, "type");
    l(this, "frequLnum");
    l(this, "frequLineCap");
    l(this, "frequDirection");
    l(this, "lineColor");
    l(this, "lineWidth");
    l(this, "radius");
    l(this, "connectDestination");
    l(this, "vbarBgColor");
    l(this, "vbarCaps");
    l(this, "vbarFillColor");
    l(this, "vbarRightColor");
    l(this, "vbarSpace");
    l(this, "vbarWidth");
    const t = Ue;
    this.canvFillColor = b(e.canvFillColor, t.canvFillColor.default), this.canvClass = b(e.canvClass, t.canvClass.default), this.circleGradient = O(e.circleGradient) ? t.circleGradient.default : e.circleGradient, this.type = b(e.type, t.type.default), this.fftSize = O(e.fftSize) ? this.type === "frequ" ? 1024 : 8192 : Number(e.fftSize), this.frequLnum = y(e.frequLnum, t.frequLnum.default), this.frequLineCap = W(e.frequLineCap, t.frequLineCap.default), this.frequDirection = b(e.frequDirection, t.frequDirection.default), this.lineColor = b(e.lineColor, t.lineColor.default), this.lineWidth = O(e.lineWidth) ? this.type === "frequ" ? 3 : 0.5 : Number(e.lineWidth), this.radius = y(e.radius, t.radius.default), this.connectDestination = W(e.connectDestination, t.connectDestination.default), this.vbarBgColor = b(e.vbarBgColor, t.vbarBgColor.default), this.vbarCaps = W(e.vbarCaps, t.vbarCaps.default), this.vbarFillColor = b(e.vbarFillColor, t.vbarFillColor.default), this.vbarRightColor = b(e.vbarRightColor, t.vbarRightColor.default), this.vbarSpace = y(e.vbarSpace, t.vbarSpace.default), this.vbarWidth = y(e.vbarWidth, t.vbarWidth.default), this.canvWidth = O(e.canvWidth) || Number(e.canvWidth) === 0 ? this.defaultWidth : Number(e.canvWidth), this.canvHeight = O(e.canvHeight) || Number(e.canvHeight) === 0 ? this.defaultHeight : Number(e.canvHeight);
  }
  get defaultWidth() {
    switch (this.type) {
      case "vbar":
        return 50;
      case "frequ":
        return 300;
      case "circle":
        return 80;
      default:
        return 200;
    }
  }
  get defaultHeight() {
    switch (this.type) {
      case "vbar":
        return 20;
      case "frequ":
        return 80;
      case "circle":
        return 80;
      default:
        return 40;
    }
  }
};
function we(n, e, t) {
  let r = null, i = null, a = null;
  const o = e || 1024, d = new Uint8Array(o / 2), { pause: c, resume: u } = Fe(() => {
    !i || (i.getByteFrequencyData(d), t(d));
  }, { immediate: false });
  x(n, "play", () => {
    const f = m(n);
    !f || (r || (r = new AudioContext(), a = r.createMediaElementSource(f)), i = r.createAnalyser(), i.fftSize = o, a == null || a.connect(i), i.connect(r.destination), r.resume(), u());
  }), x(n, "pause", () => {
    r == null || r.suspend(), a == null || a.disconnect(), i == null || i.disconnect(), c();
  });
}
function Z(n, e) {
  const t = ref(null);
  return watchEffect(() => {
    const r = m(n);
    !r || (t.value = r.getContext("2d"), r.width = e.canvWidth, r.height = e.canvHeight);
  }), t;
}
function _e(n, e, t, r) {
  n.clearRect(0, 0, e, t), r && (n.fillStyle = Pe(n, e, t, r), n.fillRect(0, 0, e, t));
}
function Pe(n, e, t, r) {
  if (!Array.isArray(r))
    return r || "";
  const i = n.createLinearGradient(e / 2, 0, e / 2, t);
  let a = 0;
  return r.forEach((o) => {
    i.addColorStop(a, o), a += 1 / r.length;
  }), i;
}
var X = Array(16).fill(0);
function zt(n, e, t) {
  const r = new je(t);
  X.length = r.fftSize / 2, X.fill(0);
  const i = Z(e, r);
  x(n, "loadedmetadata", () => {
    !r.placeholder || !i || $e(new Uint8Array(r.fftSize / 2), i, t);
  }), we(n, r.fftSize, (a) => {
    $e(a, i, t);
  });
}
function $e(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = new je(t), a = Math.round((i.barWidth + i.barSpace) / i.frqBits * i.canvWidth), o = n.length;
  let d = 0;
  _e(r, i.canvWidth, i.canvHeight, i.canvFillColor);
  for (let c = 0; c < o; c++) {
    if (c % a)
      continue;
    const u = Math.round(n.slice(c, c + a).reduce((s, h) => h + s, 0) / a), f = u / 255 * i.canvHeight;
    Et(r, i, u, c, d), r.fillStyle = Pe(r, i.canvWidth, i.canvHeight, i.barColor), i.brickHeight > 0 ? Dt(r, i, f, d) : r.fillRect(d, i.canvHeight - f - i.alignSym(f), i.barWidth, f), d += i.barWidth + i.barSpace;
  }
}
function Et(n, e, t, r, i) {
  if (e.capsHeight === 0)
    return;
  const a = X[r] <= t ? t : X[r] - e.capsDropSpeed;
  X[r] = a;
  const o = a / 255 * e.canvHeight, d = e.canvHeight - o - e.capsHeight - e.alignSym(o);
  n.fillStyle = e.capsColor, n.fillRect(i, d, e.barWidth, e.capsHeight), e.symmetric && n.fillRect(i, e.canvHeight - d - e.capsHeight, e.barWidth, e.capsHeight);
}
function Dt(n, e, t, r) {
  for (let i = 0; i < t; i += e.brickHeight + e.brickSpace)
    n.fillRect(
      r,
      e.canvHeight - t + i - e.alignSym(t),
      e.barWidth,
      e.brickHeight
    );
}
var qt = ["controls", "src"];
var $t = defineComponent({
  __name: "AVBars",
  props: Pt(),
  setup(n) {
    const e = n, t = ref(null), r = ref(null);
    return zt(t, r, e), (i, a) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, qt),
      createBaseVNode("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function It(n, e, t) {
  const r = new qe(t), i = Z(e, r);
  x(n, "loadedmetadata", () => {
    jt(i, r);
  }), we(n, r.fftSize, (a) => {
    xt(a, i, n, new qe(t));
  });
}
function xt(n, e, t, r) {
  const i = m(e);
  if (!i)
    return;
  const a = m(t);
  if (!a)
    return;
  const o = n.length, d = (r.lineWidth + r.lineSpace) / o * (2 * Math.PI);
  _e(i, r.canvWidth, r.canvHeight, r.canvFillColor), Qe(i, r), Gt(i, a, r), Vt(i, a, r), i.lineWidth = r.barWidth, i.strokeStyle = Rt(i, r);
  let c = r.angle;
  for (let u = 0; u < o; u++) {
    if (c += d, u % r.arcStep)
      continue;
    const f = Math.round(n.slice(u, u + r.arcStep).reduce((h, g) => g + h, 0) / r.arcStep), s = r.r + f / 255 * r.barLen;
    i.beginPath(), i.moveTo(r.r * Math.cos(c) + r.cx, r.r * Math.sin(c) + r.cy), i.lineTo(s * Math.cos(c) + r.cx, s * Math.sin(c) + r.cy), i.stroke();
  }
}
function jt(n, e) {
  const t = m(n);
  !t || (Qe(t, e), Xe(t, "0:00", e));
}
function Qe(n, e) {
  e.outlineWidth !== 0 && (n.beginPath(), n.strokeStyle = e.outlineColor, n.lineWidth = e.outlineWidth, n.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI), n.stroke());
}
function Gt(n, e, t) {
  if (!t.progress)
    return;
  const { currentTime: r, duration: i } = e, a = r / i * 2 * Math.PI, o = Math.PI * 1.5 + a;
  !a || (n.lineWidth = t.progressWidth, n.strokeStyle = t.progressColor, n.beginPath(), n.arc(
    t.cx,
    t.cy,
    t.r - t.outlineWidth - t.outlineMeterSpace,
    1.5 * Math.PI,
    o,
    t.progressClockwise
  ), n.stroke());
}
function Vt(n, e, t) {
  const { currentTime: r } = e, i = Math.floor(r / 60), a = Math.floor(r) % 60, o = a < 10 ? `0${a}` : `${a}`, d = `${i}:${o}`;
  Xe(n, d, t);
}
function Xe(n, e, t) {
  n.font = t.playtimeFont, n.fillStyle = t.playtimeColor, n.textAlign = "center", n.fillText(e, t.cx, t.cy + parseInt(t.playtimeFont) * 0.25);
}
function Rt(n, e) {
  if (!Array.isArray(e.barColor))
    return e.barColor;
  const t = n.createRadialGradient(e.cx, e.cy, e.canvWidth / 2, e.cx, e.cy, 0);
  let r = 0;
  return e.barColor.forEach((i) => {
    t.addColorStop(r, i), r += 1 / e.barColor.length;
  }), t;
}
var Ut = ["controls", "src"];
var Qt = defineComponent({
  __name: "AVCircle",
  props: At(),
  setup(n) {
    const e = n, t = ref(null), r = ref(null);
    return It(t, r, e), (i, a) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Ut),
      createBaseVNode("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function Xt(n, e, t) {
  const r = new De(t), i = Z(e, r);
  watch(i, () => {
    !r.placeholder || !m(i) || Ie(new Uint8Array(r.fftSize), i, r);
  }), we(n, r.fftSize, (a) => {
    Ie(a, i, new De(t));
  });
}
function Ie(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = t.canvWidth, a = t.canvHeight, o = t.lineWidth, d = n.length, c = ~~i / 2 / d;
  let u = 0;
  const f = () => {
    let s = 0;
    for (let h = 0; h < d; h++) {
      const g = n[h];
      s = a * (255 - g) / 510, h % 2 && (s = a - s), r.lineTo(u, s), u += c;
    }
    return u;
  };
  _e(r, i, a, t.canvFillColor), r.lineWidth = o, r.strokeStyle = Pe(r, i, a, t.lineColor), r.beginPath(), n.reverse(), r.moveTo(u, a / 2), u = f(), n.reverse(), f(), r.lineTo(i, a / 2), r.stroke();
}
var Yt = ["controls", "src"];
var Jt = defineComponent({
  __name: "AVLine",
  props: Ht(),
  setup(n) {
    const e = n, t = ref(null), r = ref(null);
    return Xt(t, r, e), (i, a) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, Yt),
      createBaseVNode("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
var S = [];
function Kt(n, e, t, r = {}) {
  const i = new Ot(t), a = Z(e, i);
  Zt(a, i, r);
  const { pause: o, resume: d } = Fe(() => {
    var c, u;
    i.currentTime = (u = (c = n == null ? void 0 : n.value) == null ? void 0 : c.currentTime) != null ? u : 0, pe(a, i);
  }, { immediate: false });
  x(n, "play", () => d()), x(n, "pause", () => o()), x(e, "click", (c) => {
    if (!i.playtimeClickable)
      return;
    const u = m(n);
    !u || (u.currentTime = c.offsetX / i.canvWidth * i.duration, i.currentTime = u.currentTime, pe(a, i));
  });
}
function pe(n, e) {
  const t = m(n);
  if (!t)
    return;
  let r = 0;
  t.clearRect(0, 0, e.canvWidth, e.canvHeight);
  const i = (a, o, d, c) => {
    for (t.lineWidth = d, t.strokeStyle = c, t.beginPath(); a < o; a++)
      t.moveTo(a, S[a][0]), t.lineTo(a, S[a][1]);
    return t.stroke(), a;
  };
  r = i(r, e.playX, e.playedLineWidth, e.playedLineColor), i(r, S.length, e.noplayedLineWidth, e.noplayedLineColor), Ye(t, e), e.playtime && Je(t, e);
}
function Ye(n, e) {
  n.lineWidth = e.playtimeSliderWidth, n.strokeStyle = e.playtimeSliderColor, n.beginPath(), n.moveTo(e.playX, 0), n.lineTo(e.playX, e.canvHeight), n.stroke();
}
function Je(n, e) {
  const t = e.timePlayed, r = 3, i = ~~n.measureText(t).width, a = e.playX > e.canvWidth - i - r ? e.playX - i - r : e.playX + r, o = e.playtimeTextBottom ? e.canvHeight - e.playtimeFontSize + r : e.playtimeFontSize + r;
  n.fillStyle = e.playtimeFontColor, n.font = `${e.playtimeFontSize}px ${e.playtimeFontFamily}`, n.fillText(t, a, o);
}
function Zt(n, e, t) {
  if (!e.src)
    return;
  pt(t)(e.src).arrayBuffer().then(({ error: i, data: a }) => {
    const o = m(i);
    if (o !== null) {
      console.error(`Failed get url '${e.src}': ${o}`);
      return;
    }
    if (a.value === null) {
      console.error("invalid arrayBuffer data received");
      return;
    }
    new AudioContext().decodeAudioData(a.value).then((c) => {
      e.duration = c.duration, en(c, e), pe(n, e);
    }).catch((c) => {
      console.error("Failed to decode audio array buffer:", c);
    });
  }), watchEffect(() => {
    const i = m(n);
    !i || (i.lineWidth = e.noplayedLineWidth, i.strokeStyle = e.noplayedLineColor, i.beginPath(), i.moveTo(0, e.canvHeight / 2), i.lineTo(e.canvWidth, e.canvHeight / 2), i.stroke(), Ye(i, e), e.playtime && Je(i, e));
  });
}
function en(n, e) {
  S.slice(0);
  let t = 0, r = 0, i = 0, a = 0;
  const o = Math.ceil(n.length / e.canvWidth), d = e.canvWidth, c = e.canvHeight;
  for (let u = 0; u < n.numberOfChannels; u++) {
    const f = n.getChannelData(u);
    for (let s = 0; s < d; s++) {
      const h = ~~(s * o), g = ~~(h + o);
      t = 0, r = 0;
      for (let p = h; p < g; p++)
        t = f[p] < t ? f[p] : t, r = f[p] > r ? f[p] : r;
      S[s] && (S[s][0] = S[s][0] < r ? r : S[s][0], S[s][1] = S[s][1] > t ? t : S[s][1]), S[s] = [r, t];
    }
  }
  for (let u = 0; u < S.length; u++)
    r = S[u][0], t = S[u][1], i = c / 2 - r * c / 2, a = c / 2 - t * c / 2, S[u] = [i, a === i ? i + 1 : a];
}
var tn = ["controls", "src"];
var nn = defineComponent({
  __name: "AVWaveform",
  props: Bt(),
  setup(n) {
    const e = n, t = ref(null), r = ref(null);
    return Kt(t, r, e, {
      options: { refetch: true },
      fetchOptions: { mode: "cors" }
    }), (i, a) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("audio", {
        ref_key: "player",
        ref: t,
        controls: e.audioControls,
        src: e.src
      }, null, 8, tn),
      createBaseVNode("canvas", {
        ref_key: "canvas",
        ref: r
      }, null, 512)
    ], 64));
  }
});
function rn(n, e) {
  const t = e;
  let r;
  const i = Z(n, new he(t)), { pause: a, resume: o } = Fe(() => {
    !r || on(r, i, new he(t));
  }, { immediate: false });
  watchEffect(() => {
    const d = m(t.media);
    d ? (r = an(d, new he(t)), o()) : a();
  });
}
function an(n, e) {
  const t = new AudioContext(), r = t.createAnalyser();
  return t.createMediaStreamSource(n).connect(r), r.fftSize = e.fftSize, e.connectDestination && r.connect(t.destination), r;
}
function on(n, e, t) {
  const r = m(e);
  if (!r)
    return;
  const i = new Uint8Array(n.fftSize);
  switch (t.canvFillColor && (r.fillStyle = t.canvFillColor), r.clearRect(0, 0, t.canvWidth, t.canvHeight), r.beginPath(), r.strokeStyle = t.lineColor, t.type) {
    case "frequ":
      n.getByteFrequencyData(i), ln(i, r, t);
      break;
    case "circle":
      n.getByteFrequencyData(i), sn(i, r, t);
      break;
    case "vbar":
      n.getByteFrequencyData(i), cn(i, r, t);
      break;
    default:
      n.getByteTimeDomainData(i), un(i, r, t);
      break;
  }
}
function ln(n, e, t) {
  const r = t.frequDirection === "mo", i = r ? t.canvWidth / 2 : 0, a = r ? t.frequLnum / 2 : t.frequLnum, o = r ? t.canvWidth / a / 2 : t.canvWidth / a, d = t.canvHeight, c = t.lineWidth || 2;
  for (let u = 0; u < a; u++) {
    const f = r ? u * o : u * o + c, s = n.slice(f, f + o).reduce((g, p) => g + p / 255 * d, 0) / o, h = (d - s) / 2 + 2;
    e.lineWidth = c, e.lineCap = t.frequLineCap ? "round" : "butt", e.moveTo(i + f, h), e.lineTo(i + f, d - h), e.stroke(), r && u > 0 && (e.moveTo(i - f, h), e.lineTo(i - f, d - h), e.stroke());
  }
}
function cn(n, e, t) {
  const r = t.vbarWidth, i = t.vbarSpace, a = r < 5 ? 5 : r / 2;
  let o = 0;
  for (let c = 0; c < n.length; c++)
    o = o < n[c] ? n[c] : o;
  const d = o / 255 * t.canvWidth;
  e.lineWidth = t.vbarWidth, e.lineCap = t.vbarCaps ? "round" : "butt", e.fillStyle = t.vbarBgColor, e.fillRect(0, 0, t.canvWidth, t.canvHeight);
  for (let c = r / 2; c + r + i <= t.canvWidth; c = c + r + i)
    e.strokeStyle = c > d ? t.vbarRightColor : t.vbarFillColor, e.beginPath(), e.moveTo(c, a), e.lineTo(c, t.canvHeight - a), e.stroke();
}
function sn(n, e, t) {
  const r = t.canvWidth / 2, i = t.canvHeight / 2, a = r < i ? r : i, d = Math.max(...n) / 255 * a, c = e.createRadialGradient(r, i, 0, r, i, d);
  for (const [u, f] of t.circleGradient)
    c.addColorStop(u, f);
  e.fillStyle = c, e.arc(r, i, d, 0, 2 * Math.PI), e.fill("evenodd");
}
function un(n, e, t) {
  const r = t.canvHeight, i = t.canvWidth / t.fftSize;
  let a = 0;
  e.lineWidth = t.lineWidth || 0.5;
  for (let o = 0; o < n.length; o++) {
    const c = n[o] / 255 * r;
    e.lineTo(a, c), a += i;
  }
  e.stroke();
}
var dn = defineComponent({
  __name: "AVMedia",
  props: Mt(),
  setup(n) {
    const e = n, t = ref(null);
    return rn(t, e), (r, i) => (openBlock(), createElementBlock("canvas", {
      ref_key: "canvas",
      ref: t
    }, null, 512));
  }
});
var yn = {
  install(n) {
    n.component("av-bars", $t), n.component("av-circle", Qt), n.component("av-line", Jt), n.component("av-waveform", nn), n.component("av-media", dn);
  }
};
export {
  $t as AVBars,
  Qt as AVCircle,
  Jt as AVLine,
  dn as AVMedia,
  yn as AVPlugin,
  nn as AVWaveform,
  zt as useAVBars,
  It as useAVCircle,
  Xt as useAVLine,
  rn as useAVMedia,
  Kt as useAVWaveform
};
//# sourceMappingURL=vue-audio-visual.js.map
